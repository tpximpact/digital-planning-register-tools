# ============================================================
#                  COMPONENTS SECTION
# ============================================================
components:
  # ----------------------------------------------------------
  #                  SCHEMAS
  # ----------------------------------------------------------
  # A schema defines the structure of data (objects, arrays, primitives) used in your APIâ€”such as request bodies, response bodies, or parameters.
  schemas:
    ApiResponse:
      type: object
      description: The expected format for all API responses
      properties:
        data:
          description: The actual data being returned. If no results return null
          oneOf:
            - type: 'null'
            - type: object
            - type: array
        pagination:
          description: Optional pagination data, which could be either offset or cursor-based.
          oneOf:
            - $ref: '#/components/schemas/OffsetPagination'
            - $ref: '#/components/schemas/CursorPagination'
        status:
          description: Contains the HTTP status code, a message, and optional details.
          type: object
          properties:
            code:
              type: integer
              format: int32
            message:
              type: string
            detail:
              type: string
          required:
            - code
            - message
      required:
        - data
        - status
    OffsetPagination:
      description: Recommended as the default method of pagination
      type: object
      properties:
        resultsPerPage: &propertyResultsPerPage
          type: integer
          description: Number of results per page eg 10
          format: int32
          minimum: 0
          maximum: 50
        currentPage:
          type: integer
          description: Current page number eg 1
          minimum: 1
          format: int32
        totalPages:
          type: integer
          description: Total number of pages eg 10
          minimum: 1
          format: int32
        totalResults: &propertyTotalResults
          type: integer
          description: Represents the total number of results returned by current query
          format: int32
        totalAvailableItems: &propertyTotalAvailableItems
          type: integer
          description: Represents the total number of items available in the database (#nofilter)
          format: int32
      required:
        - resultsPerPage
        - currentPage
        - totalPages
        - totalResults
    CursorPagination:
      description: optional, advanced method of pagination
      type: object
      properties:
        resultsPerPage: *propertyResultsPerPage
        nextCursor:
          type: string
          description: Cursor to the next page
        prevCursor:
          type: string
          description: Cursor to the previous page
        totalResults: *propertyTotalResults
        totalAvailableItems: *propertyTotalAvailableItems
      required:
        - resultsPerPage
        - nextCursor
        - prevCursor
        - totalResults

  # ----------------------------------------------------------
  #                  RESPONSES
  # ----------------------------------------------------------
  # A response defines the entire HTTP response for an endpoint, including status code, description, headers, and the content (which uses a schema).
  responses:
    Success:
      description: Successful operation
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseSuccessStatus
                  code: 200
                  message: 'OK'
    NotFound:
      description: The requested resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseNotFoundStatus
                  code: 404
                  message: 'Not found'
    BadRequest:
      description: The request was invalid or cannot be served
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseBadRequestStatus
                  code: 400
                  message: 'Request invalid'
    Unauthorized:
      description: The request requires user authentication
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseUnauthorizedStatus
                  code: 401
                  message: 'Authentication required'

  # ----------------------------------------------------------
  #                  PARAMETERS
  # ----------------------------------------------------------
  # A parameter defines a single input to an API endpoint, such as a query parameter, path parameter, or header.
  parameters:
    reference:
      name: reference
      in: path
      required: true
      schema: {type: string}
    resultsPerPage:
      name: resultsPerPage
      in: query
      description: Number of records to return
      schema:
        type: integer
        format: int32
        minimum: 0
        maximum: 50
      required: false
    page:
      name: page
      in: query
      description: Page number to show
      schema:
        type: integer
        format: int32
        minimum: 0
      required: false
    query:
      name: query
      in: query
      description: Search query
      schema:
        type: string
      required: false

  # ----------------------------------------------------------
  #                  EXAMPLES
  # ----------------------------------------------------------
  # An example provides a sample response or request body that can be used to illustrate the API's behavior.
  # A lot of these examples are not used as $ref, they are here to be used with yml anchors
  examples:
    # This represents an example response for the API with no search or filter applied.
    responseNoSearch:
      summary: Search results
      value:
        data: null
        pagination: &examplesResponseNoSearchPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 50
          totalAvailableItems: 50
        status: *responseSuccessStatus
    # This represents an example response for the API where there are no results at all
    responseNoResults:
      summary: No results
      value:
        data: null
        pagination: &examplesResponseNoResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 0
          totalAvailableItems: 0
        status: *responseSuccessStatus
    # This represents an example response for the API with search results
    responseSearchResults:
      summary: Search results
      value:
        data: null
        pagination: &examplesResponseSearchResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 5
          totalAvailableItems: 50
        status: *responseSuccessStatus
    # This represents an example response for the API with no results returned from a search
    responseNoSearchResults:
      summary: No search results
      value:
        data: null
        pagination: &examplesResponseNoSearchResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 0
          totalAvailableItems: 50
        status: *responseSuccessStatus

# ============================================================
#                  PATHS (ENDPOINTS)
# ============================================================
paths:
  /public/planning_application/search:
    get:
      summary: List, search, and filter planning applications
      parameters:
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum:
              [receivedAt, id, councilDecisionDate, consultationEndDate, status]
            default: receivedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
          description: Searches records by the text in the data.`application.reference`, `submission.proposal.description` and `submission.property.address` fields
        - name: reference
          in: query
          description: Search by `data.application.reference`
          schema:
            type: string
          required: false
        - name: description
          in: query
          description: Search by `submission.proposal.description`
          schema:
            type: string
          required: false
        - name: applicationType
          in: query
          description: |
            Filter by application type.
            - To filter by multiple types with AND: `?applicationType=foo&applicationType=bar`
            - To filter by multiple types with OR: `?applicationType=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  'advertConsent',
                  'amendment.minorMaterial',
                  'amendment.nonMaterial',
                  'approval.conditions',
                  'approval.reservedMatters',
                  'complianceConfirmation',
                  'environmentalImpact.scoping',
                  'environmentalImpact.screening',
                  'hazardousSubstanceConsent',
                  'hedgerowRemovalNotice',
                  'landDrainageConsent',
                  'ldc.breachOfCondition',
                  'ldc.existing',
                  'ldc.listedBuildingWorks',
                  'ldc.proposed',
                  'listed',
                  'notifyCompletion',
                  'obligation.discharge',
                  'obligation.modify',
                  'onshoreExtractionOilAndGas.other',
                  'onshoreExtractionOilAndGas.pp.extension',
                  'onshoreExtractionOilAndGas.pp.waste',
                  'onshoreExtractionOilAndGas.pp.working',
                  'onshoreExtractionOilAndGas.review',
                  'onshoreExtractionOilAndGas.variation',
                  'pa.part1.classA',
                  'pa.part1.classAA',
                  'pa.part3.classG',
                  'pa.part3.classM',
                  'pa.part3.classMA',
                  'pa.part3.classN',
                  'pa.part3.classQ',
                  'pa.part3.classR',
                  'pa.part3.classS',
                  'pa.part3.classT',
                  'pa.part3.classV',
                  'pa.part4.classBB',
                  'pa.part4.classBC',
                  'pa.part4.classCA',
                  'pa.part4.classE',
                  'pa.part6',
                  'pa.part6.classA',
                  'pa.part6.classB',
                  'pa.part6.classE',
                  'pa.part7.classC',
                  'pa.part7.classM',
                  'pa.part9.classD',
                  'pa.part11.classB',
                  'pa.part14.classA',
                  'pa.part14.classB',
                  'pa.part14.classJ',
                  'pa.part14.classK',
                  'pa.part14.classOA',
                  'pa.part16.classA',
                  'pa.part17',
                  'pa.part17.classB',
                  'pa.part17.classC',
                  'pa.part17.classG',
                  'pa.part18.classA',
                  'pa.part19.classTA',
                  'pa.part20.classA',
                  'pa.part20.classAA',
                  'pa.part20.classAB',
                  'pa.part20.classAC',
                  'pa.part20.classAD',
                  'pa.part20.classZA',
                  'pp.full',
                  'pp.full.advertConsent',
                  'pp.full.demolition',
                  'pp.full.fastTrack.affordable',
                  'pp.full.householder',
                  'pp.full.householder.listed',
                  'pp.full.householder.retro',
                  'pp.full.major',
                  'pp.full.major.technicalDetails',
                  'pp.full.major.technicalDetails.waste',
                  'pp.full.major.waste',
                  'pp.full.minor',
                  'pp.full.minor.listed',
                  'pp.full.minor.technicalDetails',
                  'pp.mineralExtraction',
                  'pp.outline',
                  'pp.outline.all',
                  'pp.outline.some',
                  'pp.outline.minor',
                  'pp.outline.minor.all',
                  'pp.outline.minor.some',
                  'pp.outline.major',
                  'pp.outline.major.all',
                  'pp.outline.major.all.waste',
                  'pp.outline.major.some',
                  'pp.outline.major.some.waste',
                  'pp.pip',
                  'rightsOfWayOrder',
                  'wtt.consent',
                  'wtt.notice',
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: stage
          in: query
          description: |
            Filter by an appplications latest stage. `data.application.stage`
            - To filter by multiple types with AND: `?stage=foo&stage=bar`
            - To filter by multiple types with OR: `?stage=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  submission,
                  validation,
                  consultation,
                  assessment,
                  appeal,
                  highCourtAppeal,
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: status
          in: query
          description: |
            Filter by status. `data.application.status`
            - To filter by multiple types with AND: `?status=foo&status=bar`
            - To filter by multiple types with OR: `?status=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [returned, withdrawn, determined, undetermined]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: councilDecision
          in: query
          description: |
            Filter by councilDecision. `data.assessment.planningOfficerDecisionDate` || `data.assessment.committeeDecisionDate`
            - To filter by multiple types with AND: `?councilDecision=foo&councilDecision=bar`
            - To filter by multiple types with OR: `?councilDecision=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [granted, refused]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: priorApprovalRequired
          in: query
          description: Only applicable on prior approval application type `data.assessment.priorApprovalRequired`
          schema:
            type: boolean
          required: false
        - name: appealDecision
          in: query
          description: |
            - To filter by multiple types with AND: `?appealDecision=foo&appealDecision=bar`
            - To filter by multiple types with OR: `?appealDecision=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [allowed, dismissed, splitDecision, withdrawn]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: hasCouncilDecisionDate
          in: query
          description: |
            `data.assessment.planningOfficerDecisionDate` || `data.assessment.committeeDecisionDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealLodgedDate
          in: query
          description: |
            `data.appeal.lodgedDate`
          schema:
            type: 'boolean'
          required: false
        - name: hasAppealValidatedDate
          in: query
          description: |
            `data.appeal.validatedDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealStartedDate
          in: query
          description: |
            `data.appeal.appealStartedDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealDecisionDate
          in: query
          description: |
            `data.appeal.appealDecisionDate`
          schema:
            type: boolean
          required: false
        - name: hasWithdrawnAt
          in: query
          description: |
            `	data.application.withdrawnAt`
          schema:
            type: boolean
          required: false

        - name: receivedAtFrom
          in: query
          description: |
            Requires `receivedAtTo`,`data.validation.receivedAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: receivedAtTo
          in: query
          description: |
            Requires `receivedAtFrom`,`data.validation.receivedAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo`,`data.validation.validatedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom`,`data.validation.validatedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo`,`metadata.publishedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom`,`metadata.publishedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: withdrawnAtFrom
          in: query
          description: |
            Requires `withdrawnAtTo`,`metadata.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: withdrawnAtTo
          in: query
          description: |
            Requires `withdrawnAtFrom`,`metadata.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: consultationEndDateFrom
          in: query
          description: |
            Requires `consultationEndDateTo`,`data.consultation.endDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: consultationEndDateTo
          in: query
          description: |
            Requires `consultationEndDateFrom`,`data.consultation.endDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: councilDecisionDateFrom
          in: query
          description: |
            Requires `councilDecisionDateTo`,`data.assessment.planningOfficerDecisionDate` \|\| `data.assessment.committeeDecisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: councilDecisionDateTo
          in: query
          description: |
            Requires `councilDecisionDateFrom`,`data.assessment.planningOfficerDecisionDate` \|\| `data.assessment.committeeDecisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealLodgedDateFrom
          in: query
          description: |
            Requires `appealLodgedDateTo`,`data.appeal.lodgedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealLodgedDateTo
          in: query
          description: |
            Requires `appealLodgedDateFrom`,`data.appeal.lodgedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealValidatedDateFrom
          in: query
          description: |
            Requires `appealValidatedDateTo`,`data.appeal.validatedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealValidatedDateTo
          in: query
          description: |
            Requires `appealValidatedDateFrom`,`data.appeal.validatedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealStartedDateFrom
          in: query
          description: |
            Requires `appealStartedDateTo`,`data.appeal.startedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealStartedDateTo
          in: query
          description: |
            Requires `appealStartedDateFrom`,`data.appeal.startedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealDecisionDateFrom
          in: query
          description: |
            Requires `appealDecisionDateTo`,`data.appeal.decisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealDecisionDateTo
          in: query
          description: |
            Requires `appealDecisionDateFrom`,`data.appeal.decisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealWithdrawnDateFrom
          in: query
          description: |
            Requires `appealWithdrawnDateTo`,`data.appeal.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealWithdrawnDateTo
          in: query
          description: |
            Requires `appealWithdrawnDateFrom`,`data.appeal.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}:
    get:
      summary: Get details of a specific planning application
      parameters:
        - $ref: '#/components/parameters/reference'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              example:
                data: {applicationType: 'abc123'}
                pagination: *examplesResponseNoSearchPagination
                status: *responseSuccessStatus
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}/documents:
    get:
      summary: List, search, and filter documents for a planning application
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [createdAt, submittedAt, validatedAt, publishedAt, name, id]
            default: submittedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
          description: Search records by `name`, `type`, `description`
        - name: name
          in: query
          description: Search records by `name`
          schema:
            format: string
          required: false
        - name: type
          in: query
          description: |
            Filter by type.
            - To filter by multiple types with AND: `?type=foo&type=bar`
            - To filter by multiple types with OR: `?type=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  'accessRoadsRightsOfWayDetails',
                  'advertsDrawings',
                  'affordableHousingStatement',
                  'arboriculturistReport',
                  'bankStatement',
                  'basementImpactStatement',
                  'bioaerosolAssessment',
                  'birdstrikeRiskManagementPlan',
                  'boreholeOrTrialPitAnalysis',
                  'buildingControlCertificate',
                  'conditionSurvey',
                  'constructionInvoice',
                  'contaminationReport',
                  'councilTaxBill',
                  'crimePreventionStrategy',
                  'designAndAccessStatement',
                  'disabilityExemptionEvidence',
                  'ecologyReport',
                  'elevations.existing',
                  'elevations.proposed',
                  'emissionsMitigationAndMonitoringScheme',
                  'energyStatement',
                  'environmentalImpactAssessment',
                  'externalMaterialsDetails',
                  'fireSafetyReport',
                  'floodRiskAssessment',
                  'floorPlan.existing',
                  'floorPlan.proposed',
                  'foulDrainageAssessment',
                  'geodiversityAssessment',
                  'hedgerowsInformation',
                  'hedgerowsInformation.plantingDate',
                  'heritageStatement',
                  'hydrologicalAssessment',
                  'hydrologyReport',
                  'internalElevations',
                  'internalSections',
                  'joinersReport',
                  'joinerySections',
                  'landContaminationAssessment',
                  'landscapeAndVisualImpactAssessment',
                  'landscapeStrategy',
                  'lightingAssessment',
                  'litterVerminAndBirdControlDetails',
                  'locationPlan',
                  'methodStatement',
                  'mineralsAndWasteAssessment',
                  'necessaryInformation',
                  'newDwellingsSchedule',
                  'noiseAssessment',
                  'openSpaceAssessment',
                  'otherDocument',
                  'otherDrawing',
                  'otherEvidence',
                  'otherSupporting',
                  'parkingPlan',
                  'photographs.existing',
                  'photographs.proposed',
                  'planningStatement',
                  'recycleWasteStorageDetails',
                  'relevantInformation',
                  'residentialUnitsDetails',
                  'roofPlan.existing',
                  'roofPlan.proposed',
                  'sections.existing',
                  'sections.proposed',
                  'sitePlan.existing',
                  'sitePlan.proposed',
                  'sketchPlan',
                  'statementOfCommunityInvolvement',
                  'statutoryDeclaration',
                  'storageTreatmentAndWasteDisposalDetails',
                  'streetScene',
                  'subsidenceReport',
                  'sunlightAndDaylightReport',
                  'sustainabilityStatement',
                  'technicalEvidence',
                  'technicalSpecification',
                  'tenancyAgreement',
                  'tenancyInvoice',
                  'townCentreImpactAssessment',
                  'townCentreSequentialAssessment',
                  'transportAssessment',
                  'travelPlan',
                  'treeAndHedgeLocation',
                  'treeAndHedgeRemovedOrPruned',
                  'treeCanopyCalculator',
                  'treeConditionReport',
                  'treesReport',
                  'treeSurvey',
                  'unitPlan.existing',
                  'unitPlan.proposed',
                  'usePlan.existing',
                  'usePlan.proposed',
                  'utilityBill',
                  'utilitiesStatement',
                  'ventilationStatement',
                  'viabilityAppraisal',
                  'visualisations',
                  'wasteAndRecyclingStrategy',
                  'wasteStorageDetails',
                  'waterEnvironmentAssessment',
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: association
          in: query
          description: |
            Filter by association.
            - To filter by multiple associations with AND: `?association=foo&association=bar`
            - To filter by multiple associations with OR: `?association=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                ['application', 'appeal', 'specialistComment', publicComment]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}/comments/public:
    get:
      summary: List, search, and filter public comments
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [submittedAt, validatedAt, publishedAt, id]
            default: publishedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
        - name: sentiment
          in: query
          description: |
            Filter by sentiment. `CommentSentiment[]`
            - To filter by multiple sentiment with AND: `?sentiment=foo&sentiment=bar`
            - To filter by multiple sentiment with OR: `?sentiment=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [objection, neutral, supportive]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: topic
          in: query
          description: |
            Filter by topic. `CommentSentiment[]`
            - To filter by multiple topic with AND: `?topic=foo&topic=bar`
            - To filter by multiple topic with OR: `?topic=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [design, use, light, privacy, access, noise, traffic, other]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: submittedAtFrom
          in: query
          description: |
            Requires `submittedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: submittedAtTo
          in: query
          description: |
            Requires `submittedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
  #   post:
  #     summary: Submit a public comment
  #     parameters:
  #       - in: path
  #         name: reference
  #         required: true
  #         schema: {type: string}
  #     requestBody:
  #       required: true
  #       content:
  #         application/json:
  #           schema:
  #             type: object # Replace with actual comment schema
  #     responses:
  #       '200':
  #         description: Comment Successful
  #         content:
  #           application/json:
  #             schema:
  #               type: object
  #               properties:
  #                 code: {type: string}
  #                 message: {type: string}
  #       '400':
  #         description: Bad Request
  #         content:
  #           application/json:
  #             schema:
  #               type: object
  #               properties:
  #                 code: {type: string}
  #                 message: {type: string}

  /public/planning_application/{reference}/comments/specialist:
    get:
      summary: List, search, and filter specialist comments
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [submittedAt, validatedAt, publishedAt, id]
            default: publishedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
        - name: sentiment
          in: query
          description: |
            Filter by sentiment. `CommentSentiment[]`
            - To filter by multiple sentiment with AND: `?sentiment=foo&sentiment=bar`
            - To filter by multiple sentiment with OR: `?sentiment=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [objection, neutral, supportive]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: topic
          in: query
          description: |
            Filter by topic. `CommentSentiment[]`
            - To filter by multiple topic with AND: `?topic=foo&topic=bar`
            - To filter by multiple topic with OR: `?topic=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [design, use, light, privacy, access, noise, traffic, other]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: submittedAtFrom
          in: query
          description: |
            Requires `submittedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: submittedAtTo
          in: query
          description: |
            Requires `submittedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
