# ============================================================
#                  OPENAPI ROOT & METADATA
# ============================================================
openapi: 3.1.0
info:
  title: Digital Planning Data schema implementation - OpenAPI 3.1
  description: |-
    One of the aims of this specification is to make data interopable between systems. JSON schema allows us to do this with the data structure but the implementation of API's will also need to have standard implementations in order for applications to use the data efficiently.

    ## Formatting data

    ##### Dates

    - The format for date only values is `YYYY-MM-DD`. Date keys should have the suffix `Date`.
    - The format for datetime values should be ISO 8601 in UTC. DateTime keys should have the suffix `At`.

    ```typescript
    interface Example {
      receivedDate: Date; // Date-only (YYYY-MM-DD)
      createdAt: DateTime; // Datetime (ISO 8601 with UTC, e.g., 2024-01-01T10:30:00Z)
    }
    ```

    ## Pagination

    To maintain consistency, it is _recommended_ to use **offset pagination** as the recommended approach. However, datasets won't always be small so API's can also support cursor-based pagination as an optional alternative for handling large datasets efficiently.

    - **Offset pagination** as the default method of pagination
    - **Cursor-based pagination** as an optional, advanced method

    ## Filter based searching

    Some endpoints support `AND` and `OR` filtering, depending on the syntax used depends on the outcome.

    `GET /items?options=option1&options=option2`

    - `SELECT * FROM items WHERE option1 = true AND option2 = true;`
    - Only items that have both option1 and option2 set to true will be returned

    `GET /items?options=option1,option2`

    - `SELECT * FROM items WHERE option1 = true OR option2 = true;`
    - Only items that have `option1` OR `option2` OR both set true will be returned

    `GET /items?options=option1&options=option2&reference=123`

    - `SELECT * FROM items WHERE option1 = true AND option2 = true AND reference = 123;`
    - Only items that have both option1 AND option2 set to true AND belong to reference 123 will be returned

    `GET /items?options=option1,option2&reference=123`

    - `SELECT * FROM items WHERE (option1 = true OR option2 = true) AND reference = 123;`
    - As long as `reference` is 123:
      - Items that have `option1` OR `option2` OR both set to true will be returned
      - Items that have neither option set to true will **not** be returned
    - Items that have `option1` OR `option2` OR both set to true but have a different reference will not be returned

    ## Date based searching

    When searching with dates, follow the convention of FieldNameDate being a Date in `YYYY-MM-DD` format and FieldNameAt being a DateTime in `2024-03-10T23:59:59Z` format

    `GET /items?from=2024-03-01&to=2024-03-10`

    `GET /items?from=2024-03-01T00:00:00Z&to=2024-03-10T23:59:59Z`

    ## Location based searching

    > [!WARNING]
    > This section is still under development

    Some endpoints support location based searching. There are two ways to search by location, single point and multipoint.

    ##### Single point

    `GET /items?lat=51.519389&lng=-0.108128&radius=10000`

    `radius` will always be defined in meters. to convert miles to meters use `meters * 0.000621371`

    The default value for radius will depend on the kind of search,

    - Small-scale searches (e.g., ATMs, cafes, petrol stations) → 500-1000 meters
    - General local searches (e.g., restaurants, businesses, events) → 2000-5000 meters (2-5 km)
    - City-wide searches (e.g., delivery zones, service providers) → 10,000-20,000 meters (10-20 km)
    - Regional searches (e.g., hospitals, large service areas) → 50,000+ meters (50+ km)

    ##### Multi point

    Using GeoJSON:

    `GET /items?polygon={"type":"Polygon","coordinates":[[[-73.97, 40.77], [-73.98, 40.75], [-73.96, 40.74], [-73.97, 40.77]]]}`

    - `Coordinates`: An array of coordinate pairs (`[longitude, latitude]`), with the first and last coordinate being the same to close the polygon.
    - `Type`: "Polygon" to specify the type of geometry.

    Simple Coordinate Pairs:

    `GET /items?polygon=longitude1,latitude1,longitude2,latitude2,longitude3,latitude3,longitude4,latitude4`
    `GET /items?polygon=-73.97,40.77,-73.98,40.75,-73.96,40.74,-73.97,40.77`

    Pass the coordinates as a comma-separated string of longitude and latitude pairs

    Some useful links:
    - [Digital Planning Data Schemas Repository](https://github.com/theopensystemslab/digital-planning-data-schemas)
    - [Implementation readme](https://github.com/theopensystemslab/digital-planning-data-schemas/blob/main/IMPLEMENTATION.md)
  version: 1.0.0
# ============================================================
#                  EXTERNAL DOCUMENTATION
# ============================================================
externalDocs:
  description: Digital planning data schema repo
  url: https://github.com/theopensystemslab/digital-planning-data-schemas
# ============================================================
#                  SERVER DEFINITIONS
# ============================================================
servers:
  - url: http://southwark.bops.localhost:3000/api/v2
    description: Local BOPS dev
  - url: '{protocol}://{localPlanningAuthority}.bops{environment}.{tld}{port}/api/{version}/{basePath}'
    description: The production API server
    variables:
      protocol:
        enum:
          - 'https'
          - 'http'
        default: 'https'
        description: |
          The protocol can be either `https` or `http`.
          This is used to differentiate between secure and non-secure connections.
          The default is `https`, which is the secure protocol.
      localPlanningAuthority:
        # note! no enum here means it is an open value
        default: camden
        description: |
          The local planning authority (LPA) is the council responsible for planning in a specific area.
          This is used to differentiate between different LPAs.
          The default is `camden`, which is the Camden LPA.
      environment:
        enum:
          - '-staging'
          - ''
        default: '-staging'
        description: |
          The environment can be either `-staging` or empty.
          This is used to differentiate between the local, staging and production environments.
          The default is `-staging`, which is the staging environment.
      version:
        enum:
          - 'v1'
          - 'v2'
        default: 'v2'
        description: |
          The API version. This is used to differentiate between different versions of the API.
          The default is `v2`, which is the latest version.
      tld:
        enum:
          - 'services'
          - 'localhost'
        default: 'services'
        description: |
          The top-level domain (TLD) can be either `services` or `local`.
          This is used to differentiate between the public and local versions of the API.
      port:
        default: ''
        description: |
          The port is optional and can be used to specify a custom port for the API.
          If not specified, it defaults to an empty string.
          **NB** You will need to prefix the port with a colon if you specify it, e.g. `:3000`.
      basePath:
        default: ''
        description: |
          The base path is optional and can be used to specify a sub-path for the API.
          If not specified, it defaults to an empty string.
# ============================================================
#                  SECURITY SCHEMES
# ============================================================
securitySchemes:
  api_key:
    type: http
    scheme: bearer
# ============================================================
#                  COMPONENTS SECTION
# ============================================================
components:
  # ----------------------------------------------------------
  #                  SCHEMAS
  # ----------------------------------------------------------
  # A schema defines the structure of data (objects, arrays, primitives) used in your API—such as request bodies, response bodies, or parameters.
  schemas:
    ApiResponse:
      type: object
      description: The expected format for all API responses
      properties:
        data:
          description: The actual data being returned. If no results return null
          oneOf:
            - type: 'null'
            - type: object
            - type: array
        pagination:
          description: Optional pagination data, which could be either offset or cursor-based.
          oneOf:
            - $ref: '#/components/schemas/OffsetPagination'
            - $ref: '#/components/schemas/CursorPagination'
        status:
          description: Contains the HTTP status code, a message, and optional details.
          type: object
          properties:
            code:
              type: integer
              format: int32
            message:
              type: string
            detail:
              type: string
          required:
            - code
            - message
      required:
        - data
        - status
    OffsetPagination:
      description: Recommended as the default method of pagination
      type: object
      properties:
        resultsPerPage: &propertyResultsPerPage
          type: integer
          description: Number of results per page eg 10
          format: int32
          minimum: 0
          maximum: 50
        currentPage:
          type: integer
          description: Current page number eg 1
          minimum: 1
          format: int32
        totalPages:
          type: integer
          description: Total number of pages eg 10
          minimum: 1
          format: int32
        totalResults: &propertyTotalResults
          type: integer
          description: Represents the total number of results returned by current query
          format: int32
        totalAvailableItems: &propertyTotalAvailableItems
          type: integer
          description: Represents the total number of items available in the database (#nofilter)
          format: int32
      required:
        - resultsPerPage
        - currentPage
        - totalPages
        - totalResults
    CursorPagination:
      description: optional, advanced method of pagination
      type: object
      properties:
        resultsPerPage: *propertyResultsPerPage
        nextCursor:
          type: string
          description: Cursor to the next page
        prevCursor:
          type: string
          description: Cursor to the previous page
        totalResults: *propertyTotalResults
        totalAvailableItems: *propertyTotalAvailableItems
      required:
        - resultsPerPage
        - nextCursor
        - prevCursor
        - totalResults

  # ----------------------------------------------------------
  #                  RESPONSES
  # ----------------------------------------------------------
  # A response defines the entire HTTP response for an endpoint, including status code, description, headers, and the content (which uses a schema).
  responses:
    Success:
      description: Successful operation
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseSuccessStatus
                  code: 200
                  message: 'OK'
    NotFound:
      description: The requested resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseNotFoundStatus
                  code: 404
                  message: 'Not found'
    BadRequest:
      description: The request was invalid or cannot be served
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseBadRequestStatus
                  code: 400
                  message: 'Request invalid'
    Unauthorized:
      description: The request requires user authentication
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ApiResponse'
          examples:
            application/json:
              summary: Default
              value:
                data: null
                status: &responseUnauthorizedStatus
                  code: 401
                  message: 'Authentication required'

  # ----------------------------------------------------------
  #                  PARAMETERS
  # ----------------------------------------------------------
  # A parameter defines a single input to an API endpoint, such as a query parameter, path parameter, or header.
  parameters:
    reference:
      name: reference
      in: path
      required: true
      schema: {type: string}
    resultsPerPage:
      name: resultsPerPage
      in: query
      description: Number of records to return
      schema:
        type: integer
        format: int32
        minimum: 0
        maximum: 50
      required: false
    page:
      name: page
      in: query
      description: Page number to show
      schema:
        type: integer
        format: int32
        minimum: 0
      required: false
    query:
      name: query
      in: query
      description: Search query
      schema:
        type: string
      required: false

  # ----------------------------------------------------------
  #                  EXAMPLES
  # ----------------------------------------------------------
  # An example provides a sample response or request body that can be used to illustrate the API's behavior.
  # A lot of these examples are not used as $ref, they are here to be used with yml anchors
  examples:
    # This represents an example response for the API with no search or filter applied.
    responseNoSearch:
      summary: Search results
      value:
        data: null
        pagination: &examplesResponseNoSearchPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 50
          totalAvailableItems: 50
        status: *responseSuccessStatus
    # This represents an example response for the API where there are no results at all
    responseNoResults:
      summary: No results
      value:
        data: null
        pagination: &examplesResponseNoResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 0
          totalAvailableItems: 0
        status: *responseSuccessStatus
    # This represents an example response for the API with search results
    responseSearchResults:
      summary: Search results
      value:
        data: null
        pagination: &examplesResponseSearchResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 5
          totalAvailableItems: 50
        status: *responseSuccessStatus
    # This represents an example response for the API with no results returned from a search
    responseNoSearchResults:
      summary: No search results
      value:
        data: null
        pagination: &examplesResponseNoSearchResultsPagination
          resultsPerPage: 10
          currentPage: 1
          totalPages: 1
          totalResults: 0
          totalAvailableItems: 50
        status: *responseSuccessStatus

# ============================================================
#                  PATHS (ENDPOINTS)
# ============================================================
paths:
  /public/planning_application/search:
    get:
      summary: List, search, and filter planning applications
      parameters:
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum:
              [receivedAt, id, councilDecisionDate, consultationEndDate, status]
            default: receivedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
          description: Searches records by the text in the data.`application.reference`, `submission.proposal.description` and `submission.property.address` fields
        - name: reference
          in: query
          description: Search by `data.application.reference`
          schema:
            type: string
          required: false
        - name: description
          in: query
          description: Search by `submission.proposal.description`
          schema:
            type: string
          required: false
        - name: applicationType
          in: query
          description: |
            Filter by application type.
            - To filter by multiple types with AND: `?applicationType=foo&applicationType=bar`
            - To filter by multiple types with OR: `?applicationType=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  'advertConsent',
                  'amendment.minorMaterial',
                  'amendment.nonMaterial',
                  'approval.conditions',
                  'approval.reservedMatters',
                  'complianceConfirmation',
                  'environmentalImpact.scoping',
                  'environmentalImpact.screening',
                  'hazardousSubstanceConsent',
                  'hedgerowRemovalNotice',
                  'landDrainageConsent',
                  'ldc.breachOfCondition',
                  'ldc.existing',
                  'ldc.listedBuildingWorks',
                  'ldc.proposed',
                  'listed',
                  'notifyCompletion',
                  'obligation.discharge',
                  'obligation.modify',
                  'onshoreExtractionOilAndGas.other',
                  'onshoreExtractionOilAndGas.pp.extension',
                  'onshoreExtractionOilAndGas.pp.waste',
                  'onshoreExtractionOilAndGas.pp.working',
                  'onshoreExtractionOilAndGas.review',
                  'onshoreExtractionOilAndGas.variation',
                  'pa.part1.classA',
                  'pa.part1.classAA',
                  'pa.part3.classG',
                  'pa.part3.classM',
                  'pa.part3.classMA',
                  'pa.part3.classN',
                  'pa.part3.classQ',
                  'pa.part3.classR',
                  'pa.part3.classS',
                  'pa.part3.classT',
                  'pa.part3.classV',
                  'pa.part4.classBB',
                  'pa.part4.classBC',
                  'pa.part4.classCA',
                  'pa.part4.classE',
                  'pa.part6',
                  'pa.part6.classA',
                  'pa.part6.classB',
                  'pa.part6.classE',
                  'pa.part7.classC',
                  'pa.part7.classM',
                  'pa.part9.classD',
                  'pa.part11.classB',
                  'pa.part14.classA',
                  'pa.part14.classB',
                  'pa.part14.classJ',
                  'pa.part14.classK',
                  'pa.part14.classOA',
                  'pa.part16.classA',
                  'pa.part17',
                  'pa.part17.classB',
                  'pa.part17.classC',
                  'pa.part17.classG',
                  'pa.part18.classA',
                  'pa.part19.classTA',
                  'pa.part20.classA',
                  'pa.part20.classAA',
                  'pa.part20.classAB',
                  'pa.part20.classAC',
                  'pa.part20.classAD',
                  'pa.part20.classZA',
                  'pp.full',
                  'pp.full.advertConsent',
                  'pp.full.demolition',
                  'pp.full.fastTrack.affordable',
                  'pp.full.householder',
                  'pp.full.householder.listed',
                  'pp.full.householder.retro',
                  'pp.full.major',
                  'pp.full.major.technicalDetails',
                  'pp.full.major.technicalDetails.waste',
                  'pp.full.major.waste',
                  'pp.full.minor',
                  'pp.full.minor.listed',
                  'pp.full.minor.technicalDetails',
                  'pp.mineralExtraction',
                  'pp.outline',
                  'pp.outline.all',
                  'pp.outline.some',
                  'pp.outline.minor',
                  'pp.outline.minor.all',
                  'pp.outline.minor.some',
                  'pp.outline.major',
                  'pp.outline.major.all',
                  'pp.outline.major.all.waste',
                  'pp.outline.major.some',
                  'pp.outline.major.some.waste',
                  'pp.pip',
                  'rightsOfWayOrder',
                  'wtt.consent',
                  'wtt.notice',
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: stage
          in: query
          description: |
            Filter by an appplications latest stage. `data.application.stage`
            - To filter by multiple types with AND: `?stage=foo&stage=bar`
            - To filter by multiple types with OR: `?stage=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  submission,
                  validation,
                  consultation,
                  assessment,
                  appeal,
                  highCourtAppeal,
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: status
          in: query
          description: |
            Filter by status. `data.application.status`
            - To filter by multiple types with AND: `?status=foo&status=bar`
            - To filter by multiple types with OR: `?status=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [returned, withdrawn, determined, undetermined]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: councilDecision
          in: query
          description: |
            Filter by councilDecision. `data.assessment.planningOfficerDecisionDate` || `data.assessment.committeeDecisionDate`
            - To filter by multiple types with AND: `?councilDecision=foo&councilDecision=bar`
            - To filter by multiple types with OR: `?councilDecision=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [granted, refused]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: priorApprovalRequired
          in: query
          description: Only applicable on prior approval application type `data.assessment.priorApprovalRequired`
          schema:
            type: boolean
          required: false
        - name: appealDecision
          in: query
          description: |
            - To filter by multiple types with AND: `?appealDecision=foo&appealDecision=bar`
            - To filter by multiple types with OR: `?appealDecision=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [allowed, dismissed, splitDecision, withdrawn]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: hasCouncilDecisionDate
          in: query
          description: |
            `data.assessment.planningOfficerDecisionDate` || `data.assessment.committeeDecisionDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealLodgedDate
          in: query
          description: |
            `data.appeal.lodgedDate`
          schema:
            type: 'boolean'
          required: false
        - name: hasAppealValidatedDate
          in: query
          description: |
            `data.appeal.validatedDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealStartedDate
          in: query
          description: |
            `data.appeal.appealStartedDate`
          schema:
            type: boolean
          required: false
        - name: hasAppealDecisionDate
          in: query
          description: |
            `data.appeal.appealDecisionDate`
          schema:
            type: boolean
          required: false
        - name: hasWithdrawnAt
          in: query
          description: |
            `	data.application.withdrawnAt`
          schema:
            type: boolean
          required: false

        - name: receivedAtFrom
          in: query
          description: |
            Requires `receivedAtTo`,`data.validation.receivedAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: receivedAtTo
          in: query
          description: |
            Requires `receivedAtFrom`,`data.validation.receivedAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo`,`data.validation.validatedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom`,`data.validation.validatedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo`,`metadata.publishedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom`,`metadata.publishedAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: withdrawnAtFrom
          in: query
          description: |
            Requires `withdrawnAtTo`,`metadata.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: withdrawnAtTo
          in: query
          description: |
            Requires `withdrawnAtFrom`,`metadata.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: boolean
          required: false
        - name: consultationEndDateFrom
          in: query
          description: |
            Requires `consultationEndDateTo`,`data.consultation.endDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: consultationEndDateTo
          in: query
          description: |
            Requires `consultationEndDateFrom`,`data.consultation.endDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: councilDecisionDateFrom
          in: query
          description: |
            Requires `councilDecisionDateTo`,`data.assessment.planningOfficerDecisionDate` \|\| `data.assessment.committeeDecisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: councilDecisionDateTo
          in: query
          description: |
            Requires `councilDecisionDateFrom`,`data.assessment.planningOfficerDecisionDate` \|\| `data.assessment.committeeDecisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealLodgedDateFrom
          in: query
          description: |
            Requires `appealLodgedDateTo`,`data.appeal.lodgedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealLodgedDateTo
          in: query
          description: |
            Requires `appealLodgedDateFrom`,`data.appeal.lodgedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealValidatedDateFrom
          in: query
          description: |
            Requires `appealValidatedDateTo`,`data.appeal.validatedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealValidatedDateTo
          in: query
          description: |
            Requires `appealValidatedDateFrom`,`data.appeal.validatedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealStartedDateFrom
          in: query
          description: |
            Requires `appealStartedDateTo`,`data.appeal.startedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealStartedDateTo
          in: query
          description: |
            Requires `appealStartedDateFrom`,`data.appeal.startedDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealDecisionDateFrom
          in: query
          description: |
            Requires `appealDecisionDateTo`,`data.appeal.decisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealDecisionDateTo
          in: query
          description: |
            Requires `appealDecisionDateFrom`,`data.appeal.decisionDate`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealWithdrawnDateFrom
          in: query
          description: |
            Requires `appealWithdrawnDateTo`,`data.appeal.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: appealWithdrawnDateTo
          in: query
          description: |
            Requires `appealWithdrawnDateFrom`,`data.appeal.withdrawnAt`. Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                        {applicationType: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}:
    get:
      summary: Get details of a specific planning application
      parameters:
        - $ref: '#/components/parameters/reference'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              example:
                data: {applicationType: 'abc123'}
                pagination: *examplesResponseNoSearchPagination
                status: *responseSuccessStatus
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}/documents:
    get:
      summary: List, search, and filter documents for a planning application
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [createdAt, submittedAt, validatedAt, publishedAt, name, id]
            default: submittedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
          description: Search records by `name`, `type`, `description`
        - name: name
          in: query
          description: Search records by `name`
          schema:
            format: string
          required: false
        - name: type
          in: query
          description: |
            Filter by type.
            - To filter by multiple types with AND: `?type=foo&type=bar`
            - To filter by multiple types with OR: `?type=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                [
                  'accessRoadsRightsOfWayDetails',
                  'advertsDrawings',
                  'affordableHousingStatement',
                  'arboriculturistReport',
                  'bankStatement',
                  'basementImpactStatement',
                  'bioaerosolAssessment',
                  'birdstrikeRiskManagementPlan',
                  'boreholeOrTrialPitAnalysis',
                  'buildingControlCertificate',
                  'conditionSurvey',
                  'constructionInvoice',
                  'contaminationReport',
                  'councilTaxBill',
                  'crimePreventionStrategy',
                  'designAndAccessStatement',
                  'disabilityExemptionEvidence',
                  'ecologyReport',
                  'elevations.existing',
                  'elevations.proposed',
                  'emissionsMitigationAndMonitoringScheme',
                  'energyStatement',
                  'environmentalImpactAssessment',
                  'externalMaterialsDetails',
                  'fireSafetyReport',
                  'floodRiskAssessment',
                  'floorPlan.existing',
                  'floorPlan.proposed',
                  'foulDrainageAssessment',
                  'geodiversityAssessment',
                  'hedgerowsInformation',
                  'hedgerowsInformation.plantingDate',
                  'heritageStatement',
                  'hydrologicalAssessment',
                  'hydrologyReport',
                  'internalElevations',
                  'internalSections',
                  'joinersReport',
                  'joinerySections',
                  'landContaminationAssessment',
                  'landscapeAndVisualImpactAssessment',
                  'landscapeStrategy',
                  'lightingAssessment',
                  'litterVerminAndBirdControlDetails',
                  'locationPlan',
                  'methodStatement',
                  'mineralsAndWasteAssessment',
                  'necessaryInformation',
                  'newDwellingsSchedule',
                  'noiseAssessment',
                  'openSpaceAssessment',
                  'otherDocument',
                  'otherDrawing',
                  'otherEvidence',
                  'otherSupporting',
                  'parkingPlan',
                  'photographs.existing',
                  'photographs.proposed',
                  'planningStatement',
                  'recycleWasteStorageDetails',
                  'relevantInformation',
                  'residentialUnitsDetails',
                  'roofPlan.existing',
                  'roofPlan.proposed',
                  'sections.existing',
                  'sections.proposed',
                  'sitePlan.existing',
                  'sitePlan.proposed',
                  'sketchPlan',
                  'statementOfCommunityInvolvement',
                  'statutoryDeclaration',
                  'storageTreatmentAndWasteDisposalDetails',
                  'streetScene',
                  'subsidenceReport',
                  'sunlightAndDaylightReport',
                  'sustainabilityStatement',
                  'technicalEvidence',
                  'technicalSpecification',
                  'tenancyAgreement',
                  'tenancyInvoice',
                  'townCentreImpactAssessment',
                  'townCentreSequentialAssessment',
                  'transportAssessment',
                  'travelPlan',
                  'treeAndHedgeLocation',
                  'treeAndHedgeRemovedOrPruned',
                  'treeCanopyCalculator',
                  'treeConditionReport',
                  'treesReport',
                  'treeSurvey',
                  'unitPlan.existing',
                  'unitPlan.proposed',
                  'usePlan.existing',
                  'usePlan.proposed',
                  'utilityBill',
                  'utilitiesStatement',
                  'ventilationStatement',
                  'viabilityAppraisal',
                  'visualisations',
                  'wasteAndRecyclingStrategy',
                  'wasteStorageDetails',
                  'waterEnvironmentAssessment',
                ]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: association
          in: query
          description: |
            Filter by association.
            - To filter by multiple associations with AND: `?association=foo&association=bar`
            - To filter by multiple associations with OR: `?association=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum:
                ['application', 'appeal', 'specialistComment', publicComment]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                        {document: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'

  /public/planning_application/{reference}/comments/public:
    get:
      summary: List, search, and filter public comments
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [submittedAt, validatedAt, publishedAt, id]
            default: publishedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
        - name: sentiment
          in: query
          description: |
            Filter by sentiment. `CommentSentiment[]`
            - To filter by multiple sentiment with AND: `?sentiment=foo&sentiment=bar`
            - To filter by multiple sentiment with OR: `?sentiment=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [objection, neutral, supportive]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: topic
          in: query
          description: |
            Filter by topic. `CommentSentiment[]`
            - To filter by multiple topic with AND: `?topic=foo&topic=bar`
            - To filter by multiple topic with OR: `?topic=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [design, use, light, privacy, access, noise, traffic, other]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: submittedAtFrom
          in: query
          description: |
            Requires `submittedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: submittedAtTo
          in: query
          description: |
            Requires `submittedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
  #   post:
  #     summary: Submit a public comment
  #     parameters:
  #       - in: path
  #         name: reference
  #         required: true
  #         schema: {type: string}
  #     requestBody:
  #       required: true
  #       content:
  #         application/json:
  #           schema:
  #             type: object # Replace with actual comment schema
  #     responses:
  #       '200':
  #         description: Comment Successful
  #         content:
  #           application/json:
  #             schema:
  #               type: object
  #               properties:
  #                 code: {type: string}
  #                 message: {type: string}
  #       '400':
  #         description: Bad Request
  #         content:
  #           application/json:
  #             schema:
  #               type: object
  #               properties:
  #                 code: {type: string}
  #                 message: {type: string}

  /public/planning_application/{reference}/comments/specialist:
    get:
      summary: List, search, and filter specialist comments
      parameters:
        - $ref: '#/components/parameters/reference'
        - $ref: '#/components/parameters/resultsPerPage'
        - $ref: '#/components/parameters/page'
        - name: sortBy
          in: query
          description: What field to sort by
          schema:
            enum: [submittedAt, validatedAt, publishedAt, id]
            default: publishedAt
            format: string
          required: false
        - name: orderBy
          in: query
          description: What order to sort by
          schema:
            enum: [asc, desc]
            default: desc
            format: string
          required: false
        - $ref: '#/components/parameters/query'
        - name: sentiment
          in: query
          description: |
            Filter by sentiment. `CommentSentiment[]`
            - To filter by multiple sentiment with AND: `?sentiment=foo&sentiment=bar`
            - To filter by multiple sentiment with OR: `?sentiment=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [objection, neutral, supportive]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false
        - name: topic
          in: query
          description: |
            Filter by topic. `CommentSentiment[]`
            - To filter by multiple topic with AND: `?topic=foo&topic=bar`
            - To filter by multiple topic with OR: `?topic=foo,bar`
            - Both syntaxes are supported but this example uses the OR syntax
          schema:
            type: array
            items:
              type: string
              enum: [design, use, light, privacy, access, noise, traffic, other]
          style: form
          explode: false # set to false for OR query and true for AND query
          required: false

        - name: submittedAtFrom
          in: query
          description: |
            Requires `submittedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: submittedAtTo
          in: query
          description: |
            Requires `submittedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtFrom
          in: query
          description: |
            Requires `validatedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: validatedAtTo
          in: query
          description: |
            Requires `validatedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtFrom
          in: query
          description: |
            Requires `publishedAtTo` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
        - name: publishedAtTo
          in: query
          description: |
            Requires `publishedAtFrom` Format: YYYY-MM-DD.
          schema:
            type: string
            format: date
          required: false
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiResponse'
              examples:
                results:
                  summary: Results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseNoSearchPagination
                    status: *responseSuccessStatus
                noResults:
                  $ref: '#/components/examples/responseNoResults'
                searchResults:
                  summary: Search results
                  value:
                    data:
                      [
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                        {comment: 'abc123'},
                      ]
                    pagination: *examplesResponseSearchResultsPagination
                    status: *responseSuccessStatus
                noSearchResults:
                  $ref: '#/components/examples/responseNoSearchResults'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
